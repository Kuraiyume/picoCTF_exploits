# homework picoCTF Binary Exploitation Hard Difficulty

![IMG](https://github.com/Kuraiyume/picoCTF_exploits/blob/main/Screenshot%20(457).png)

First, let's analyze the binary using Ghidra. Since it’s not stripped, we can easily read the disassembly because we can see the names of the global variables and other helpful information. The main function works like this:
1. It copies a string that seems to be a flag into a global variable called flag.
2. It allocates a memory area of 1100 bytes for a global variable named board. The input string is stored in the first four lines of this memory area.
3. The function step keeps getting called repeatedly until it returns 0.
To move forward, we really need to understand what the step function does. However, when I looked at the disassembled code in Ghidra, I was overwhelmed by its length. (I had actually given up last time because it seemed so daunting.) The first part looks like this.

![IMG](https://github.com/Kuraiyume/picoCTF_exploits/blob/main/Screenshot%20(456).png)

If you examine it closely, you'll notice the presence of global variables pcx and pcy, which determine the process based on the characters found at board[pcy][pcx]. The first character in the switch statement, “! (0x21),” indicates that two global variables, sn and stack, are being utilized. The most evident characters are “> < ^ v,” which modify the values of the global variables dirx and diry. These four symbols can be interpreted as arrows, pointing in specific directions that affect the vector (dirx, diry). At the end of the step function, these dirx and diry variables dictate the next direction to move on the board.
pcx=(pcx+dirx+cols) mod cols
pcy=(pcy+diry+rows) mod rows

Upon reviewing the other processes, we can interpret the global variables stack and sn as follows: stack functions as a stack specifically designed for a 32-bit environment, while sn serves as the stack pointer. Within the step function, certain characters are processed in a specialized manner, although not all characters are included in this processing. The stack can be envisioned as an array of type int, with sn indicating the next position for a push operation. As a result, the most recently added elements can be referenced as stack[sn-1] and stack[sn-2].
This list describes an operation that manipulates a stack and potentially interacts with a two-dimensional array (referred to as board):

1. `0`: push 0  
2. `!`: pop x, then push (x == 0)  
3. `+`: pop x, pop y, then push (y + x)  
4. `*`: pop x, pop y, then push (y * x)  
5. `:`: push stack[sn - 1]  
6. `****`: swap(stack[sn - 1], stack[sn - 2])  
7. `****`: pop x, pop y, then push (x < y)  
8. `g`: pop y, pop x, and if (0 <= x <= 0x16 && 0 <= y <= 0x32), then push board[y][x]  
9. `p`: pop y, pop x, pop u, and if (0 <= x <= 0x16 && 0 <= y <= 0x32), then board[y][x] = u  
10. `@`: exit  
11. `,`: pop x, then putchar(x)  
12. `.`: pop x, then printf("%d", x)  

There are several other aspects to consider, but at its core, the fundamentals can be summarized as follows. The processing of the character \ may present some challenges when examining the source code, primarily because it relies heavily on xor operations. This extensive use of xor might make it difficult for readers to grasp the underlying logic at first glance. However, the actual steps involved in this processing are detailed below. To enhance comprehension, it's important to recognize the property of the xor operation: when you xor the same value with itself, the result is always 0. This key characteristic can significantly aid in understanding how the code functions. By breaking down the process and keeping this property in mind, the logic behind the implementation becomes more accessible, allowing for a clearer grasp of how the processing unfolds.
- stack[sn - 1] ^= stack[sn - 2];
- stack[sn - 2] ^= stack[sn - 1];
- stack[sn - 1] ^= stack[sn - 2];
Once you grasp concepts like this, you'll be able to determine the appropriate input character. For instance, if we use the input string 0!, it effectively translates to push 1 (with dirx=1, diry=0, meaning that the initial direction is set to the right). There are other strings that can achieve push n with a similarly concise format, although some may be shorter. Here are a few examples.
1. `0`: 0  
2. `1`: 0!  
3. `2`: 0!:+  
4. `3`: 0!::++  
5. `4`: 0!:+:+  
6. `5`: 0!::+:++  
7. `6`: 0!:+::++  
8. `7`: 0!::+::+++  
9. `8`: 0!:+:+:+  
10. `9`: 0!::++:*  
11. `10`: 0!::+:++:+  
12. `11`: 0!:::+:++:++  
13. `12`: 0!:+::++:+  
14. `13`: 0!::+::++:++  
15. `14`: 0!::+::+++:+  
16. `15`: 0!::+:++::++  
17. `16`: 0!:+:*:*  
18. `17`: 0!::+:*:*+  
19. `18`: 0!::++:*:+  
20. `19`: 0!:::++:*:++  
21. `20`: 0!::+:++:+:+  
22. `21`: 0!:::+:++:+:++  

I’ve made significant progress in understanding the program, but I’m unsure how to proceed effectively. Since the flags are already expanded in memory, it doesn't resemble a typical shell exploitation scenario, and input/output isn’t an issue. Even attempts to target the abort function in __assert_fail, similar to the house of orange, are thwarted by the inability to write to memory initially. After closely examining the code, I noticed an off-by-one error in the processing of the g and p instructions: when accessing board[y][x], it checks if x and y are within the range of 0 <= x <= 0x16, when it should actually allow for access slightly beyond the intended limits. This oversight means that while the board's size is 0x440 bytes, it can be accessed up to 0x32 * 0x16 * 0x16 = 0x462 bytes. Although the distance from the board to the flag is 0x480, which is out of reach, there exists a global variable called "rows" located just behind the board area that can be rewritten, thereby extending access further. If the stack state right before executing p is set correctly, with the address of rows equal to the address of board + 0x32 * 0x16, it becomes possible to modify the value of rows to u.

We aim to set u to the highest possible value, and this string 00!- is effective for this purpose. It pushes 0 and 1 onto the stack in order, then uses the - instruction to pop both values, resulting in the push of 0 - 1, which equals 0xffffffffff.

00!- appears to be an effective option for pushing 0x32 (which is 50) onto the stack. Given the constraints on the input string, a concise option would be preferable. This is a list of the most common issues encountered with the 0!::+::+++:*0!+

This involves pushing 7 onto the stack, squaring it, adding 1, and continuing with further calculations. Since we couldn't identify a payload that fit within 0x16 characters, we opted to use the arrow instructions ><^v and utilized the second line and beyond. After modifying the value of rows to 0xff with the p instruction, we can produce output using the g and, instructions, employing a similar approach. I developed an exploit in Python to address the challenge, and during the actual attack, one character was leaked per connection, allowing the flag to be retrieved by establishing multiple connections. (The exploit is uploaded in this repository)

![IMG](https://github.com/Kuraiyume/picoCTF_exploits/blob/main/Screenshot%20(458).png)

This is the full Flag with a bytes on it. Xd!!!!
